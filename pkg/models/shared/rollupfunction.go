// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type RollupFunctionAggregator string

const (
	RollupFunctionAggregatorRollupAggregatorSum   RollupFunctionAggregator = "ROLLUP_AGGREGATOR_SUM"
	RollupFunctionAggregatorRollupAggregatorCount RollupFunctionAggregator = "ROLLUP_AGGREGATOR_COUNT"
	RollupFunctionAggregatorRollupAggregatorMin   RollupFunctionAggregator = "ROLLUP_AGGREGATOR_MIN"
	RollupFunctionAggregatorRollupAggregatorMax   RollupFunctionAggregator = "ROLLUP_AGGREGATOR_MAX"
	RollupFunctionAggregatorRollupAggregatorAvg   RollupFunctionAggregator = "ROLLUP_AGGREGATOR_AVG"
)

func (e RollupFunctionAggregator) ToPointer() *RollupFunctionAggregator {
	return &e
}

func (e *RollupFunctionAggregator) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ROLLUP_AGGREGATOR_SUM":
		fallthrough
	case "ROLLUP_AGGREGATOR_COUNT":
		fallthrough
	case "ROLLUP_AGGREGATOR_MIN":
		fallthrough
	case "ROLLUP_AGGREGATOR_MAX":
		fallthrough
	case "ROLLUP_AGGREGATOR_AVG":
		*e = RollupFunctionAggregator(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RollupFunctionAggregator: %v", v)
	}
}

// RollupFunction - Rollup function aggregates the slices of metrics returned by original query and lets you operate on the slices using aggregator and constructs the bigger slice of your choice of interval (specified in seconds).
type RollupFunction struct {
	Aggregator *RollupFunctionAggregator `json:"aggregator,omitempty"`
	Interval   *int64                    `json:"interval,omitempty"`
}
